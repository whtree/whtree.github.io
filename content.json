{"meta":{"title":"博客","subtitle":"","description":"游戏技术博客","author":"Tree","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2023-07-11T13:22:11.000Z","updated":"2023-07-11T13:55:53.458Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Tree Blog"},{"title":"archive","date":"2023-07-11T13:21:33.000Z","updated":"2023-07-11T13:27:03.762Z","comments":true,"path":"archive/index.html","permalink":"http://example.com/archive/index.html","excerpt":"","text":""},{"title":"gallery","date":"2023-07-11T13:59:46.000Z","updated":"2023-07-11T13:59:46.491Z","comments":true,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":""},{"title":"category","date":"2023-07-11T13:21:48.000Z","updated":"2023-07-11T13:27:53.097Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"home","date":"2023-07-11T13:21:18.000Z","updated":"2023-07-11T13:28:19.682Z","comments":true,"path":"home/index.html","permalink":"http://example.com/home/index.html","excerpt":"","text":""},{"title":"tag","date":"2023-07-11T13:21:59.000Z","updated":"2023-07-11T13:28:19.681Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""},{"title":"tagcloud","date":"2023-07-11T13:59:34.000Z","updated":"2023-07-11T13:59:34.031Z","comments":true,"path":"tagcloud/index.html","permalink":"http://example.com/tagcloud/index.html","excerpt":"","text":""},{"title":"timeline","date":"2023-07-11T13:57:43.000Z","updated":"2023-07-11T13:57:43.142Z","comments":true,"path":"timeline/index.html","permalink":"http://example.com/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"DrawCall","slug":"DrawCall","date":"2023-07-11T14:36:41.000Z","updated":"2023-07-11T14:37:21.552Z","comments":true,"path":"2023/07/11/DrawCall/","link":"","permalink":"http://example.com/2023/07/11/DrawCall/","excerpt":"","text":"Drawcall DrawCall:绘制调用，指CPU调用图形绘制接口命令GPU进行图形绘制。 DrawCall 中文译为“绘制调用”或“绘图指令”。 DrawCall 是一种行为（指令），即CPU调用图形API，命令GPU进行图形绘制。 一般来说GPU渲染图像的速度其实是非常快的。但是CPU的内存显存读写、数据处理和渲染状态切换相对于GPU渲染来说是非常非常慢的。实际的瓶颈在于CPU这边，大量的DrawCall会让CPU忙到焦头烂额晕头转向不可开交，而GPU大部分时间都在摸鱼，是导致游戏性能下降的主要原因。 降低DrawCall的方法 1.相同类型（图片，文本等）的节点尽量在一起，防止打断合批 2.用第三方软件TexturePacker等打包图集，同一个界面上的碎图尽量打包在同一图集上 3.用引擎自带的自动图集资源（Auto Atlas）(静态合图)打包碎图,效果只在打包后才会显示。 4.引擎动态合图功能，默认自动开启，因动态合图会增加内存，小游戏和app平台禁用动态合图。 1234cc.macro.CLEANUP_IMAGE_CACHE = false;cc.dynamicAtlasManager.enabled = true;cc.dynamicAtlasManager.maxFrameSize = 512;cc.dynamicAtlasManager.showDebug(true); 优化DrawCall方案1.DrawCall -CPU发送指令GPU绘制界面 Cocos Creator ScrollView 性能优化 不改引擎源码实现虚拟列表合批策略 【分享】利用PostRender实现分层合批渲染（附 Demo 和引擎源码解读）","categories":[{"name":"游戏优化","slug":"游戏优化","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"drawcall","slug":"drawcall","permalink":"http://example.com/tags/drawcall/"}]},{"title":"JS 基础","slug":"JS_Base/JS","date":"2023-07-11T13:29:32.000Z","updated":"2023-07-11T14:11:38.751Z","comments":true,"path":"2023/07/11/JS_Base/JS/","link":"","permalink":"http://example.com/2023/07/11/JS_Base/JS/","excerpt":"","text":"NOTESjs 基础 所有的数字类型,在JavaScript中,都是双倍精度的浮点数类型 Javascript的数字类型是双精度浮点型. 在Javascript中,整型是double的一个子集,而不是一个独立的数据类型. Javascript在进行位运算的时候会把数字转换成32位整型来进行处理. 浮点数运算是不准确的,拥有许多的局限性. javaScript最大值为2的53次方&#x3D;&#x3D;&#x3D;9007199254740992。 ‘|’ 与 ‘||’JS 单竖线运算符在js开发应用中我们通常会碰到&#39;|&#39;与&#39;||&#39;了，那么在运算中&#39;|&#39;与&#39;||&#39;是什么意思呢？在js整数操作的时候，相当于去除小数点，parseInt。在正数的时候相当于Math.floor(),负数的时候相当于Math.ceil() 注： Math.ceil()用作向上取整。 Math.floor()用作向下取整。 Math.round() 我们数学中常用到的四舍五入取整。12345console.log(0.6|0)//0console.log(1.1|0)//1console.log(3.65555|0)//3console.log(5.99999|0)//5console.log(-7.777|0)//-7 单竖杠的运算规则 看了上面的例子，大体知道单竖杠可以进行取整运算，就是只保留正数部分，小数部分通过拿掉，但是&#39;|0&#39;，又是如何进行运算的呢，为什么能&#39;|0&#39;能达到取整的目的呢？单竖杠不是0有会是多少呢？ 带着这些问题，我们看下面例子： 12345console.log(3|4);//7console.log(4|4);//4console.log(8|3);//11console.log(5.3|4.1);//5console.log(9|3455);//3455 这里面提到了单竖杠&#39;|&#39;但是没有javascript的。好吧，我在这里公布答案吧。其实单竖杠&#39;|&#39;就是转换为2进制之后相加得到的结果。例如我们拿简单的举例： 3|4转换为二进制之后011|100 相加得到111&#x3D;74|4转换为二进制之后100 |100 相加得到100&#x3D;48|3转换为二进制之后1000 |011 相加得到1011&#x3D;11 以此类推，我在这里就不一一列举了，单竖杠&#39;|&#39;运算就是转换为2进制之后相加得到的结果！ JS 双竖线运算符1、JS双竖线运算符:是或比较.如null||&#39;1&#39;,返回&#39;1&#39;;&#39;2&#39;||&#39;1&#39;,返回&#39;2&#39;.即或运算符中,第一个为真,后面的就不用计算了.所以得&#39;2&#39;。2、js 中 使用双竖线运算符&quot;||&quot;,返回第一个有效值 1234var objOne = undefined || 1 || null || new Date(); var objTwo = new Date(); var objThree = objOne || objTwo; console.log(objThree.toString()); //out put &quot;1&quot; 性能上的比较 逻辑运算符&amp;&amp; || 中，如果&amp;&amp;的第一个运算数是false，就不再考虑第二个运算数，直接返回false；如果||的第一个运算数是true，也不再考虑第二个运算数，直接返回true。而&amp;和|运算符却不是这样的，它们总是要比较两个运算数才得出结果，因而性能上&amp;&amp;和||会比&amp;和|好。 功能用法 &amp;&amp;和||只能进行逻辑运算，而&amp;和|除了可以进行”逻辑运算”外，还可以进行位运算 位运算 &amp;和|本是位运算符，之所以可以进行”逻辑运算”，是由于JS是无类型的语言、各数据类型可以自由转换这一特性决定的，当用&amp;和|进行”逻辑运算”时，实际上true被转换成1，false被转换成0，再进行逐位运算： 1234console.log(true &amp; false); //JS，结果为0// 上面这句，实例等同于逻辑运算被转化成下面的位运算，并执行：console.log(1 &amp; 0); //JS，结果为0// 也正是由于&amp;和|是逐位运算符，才出现了第一点中所说的，它们总是要比较两个运算数才得出结果，才导致性能会比&amp;&amp;和||低一些。 eval eval可以将字符串生成语句执行， 和SQL的exec()类似。 eval的使用场合是什么呢？有时候我们预先不知道要执行什么语句，只有 当条件和参数给时才知道执行什么语句，这时候eval就派上用场了。举个例子： 我们要做一个function()，功能是输入网页中两个个对象的名称，然后程序就将这两个对象的值联接起来输出。 1234567function output(a,b)&#123; var tmpa,tmpb; tmpa=document.all.a.value; tmpb=document.all.b.value; document.write(tmpa+tmpb);&#125;output(&#x27;input1&#x27;,&#x27;input2&#x27;); 这样你执行的时候就会提示错误“document.all.a不是对象”以及“document.all.b不是对象”。原来javascript把a和 b当成对象名称了，怎样能让javascript把a里面的值作为对象名称呢？这时候就要用eval了，把代码改成这样： 1234567function output(a,b)&#123;var tmpa,tmpb;tmpa=eval(&quot;document.all.&quot;+a+&quot;.value&quot;);tmpb=eval(&quot;document.all.&quot;+b+&quot;.value&quot;);document.write(tmpa+tmpb);&#125;output(&#x27;input1&#x27;,&#x27;input2&#x27;); 这样javascript就会先取出a,b的值，然后和前面的document.all.以及后面的.value组合运行，于是就可以顺利取出input1和input2的值. 参考 JS截取字符串 substringstring.substring(from, to) 方法从 from 位置截取到 to 位置，to 可选，没有设置时默认到末尾。 123var str=&quot;www.runoob.com!&quot;;console.log(str.substring(4)); // 从第 5 个字符开始截取到末尾console.log(str.substring(4,10)); // 从第 5 个字符开始截取到第10个字符 substrsubstr方法可在字符串中截取从开始下标开始的指定数目的字符。 12var str=&quot;www.runoob.com!&quot;;console.log(str.substr(4,6)); // 从第 4 个字符开始截取6个字符 sliceslice(start,end) 方法用于提取字符串的某个部分（从参数 start 到 end 位置），并以新的字符串返回被提取的部分。类似 substring()。 123var str=&quot;www.runoob.com!&quot;;console.log(str.slice(4)); // 从第 5 个字符开始截取到末尾console.log(str.slice(4,10)); // 从第 5 个字符开始截取到第10个字符","categories":[{"name":"JS Base","slug":"JS-Base","permalink":"http://example.com/categories/JS-Base/"}],"tags":[{"name":"技术 语言","slug":"技术-语言","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"}]},{"title":"for","slug":"JS_Base/for","date":"2023-07-11T13:29:32.000Z","updated":"2023-07-11T14:11:55.519Z","comments":true,"path":"2023/07/11/JS_Base/for/","link":"","permalink":"http://example.com/2023/07/11/JS_Base/for/","excerpt":"","text":"forfor in 与 for of 的区别？ 遍历对象 for…in 遍历对象的属性 for…of 用来遍历具有iterator接口的数据结构（set map arguments NodeList） 遍历数组 for…in 遍历的是数组的索引 for…of 遍历的是数组的值 forEach 不能使用break continue for…in for…of可以使用 for of 遍历对象 Object.keys argument NodeList 123456789function foo2() &#123; for (const iterator of arguments) &#123; console.log(iterator); &#125;&#125;foo2(1,2,3)// 1// 2// 3 不能遍历 Symbol 属性123456789101112131415161718192021222324let as = Symbol(&#x27;a&#x27;);let bs = Symbol(&#x27;b&#x27;);let obj = &#123; [as]: &#x27;as&#x27;, [bs]: &#x27;bs&#x27;, name: &#x27;obj&#x27;, age: 23&#125;for (let key in obj) &#123; // console.log(key);&#125;// name// age// 可以遍历Symbol的方法// Object.getOwnPropertySymbols()let objGetSymbol = Object.getOwnPropertySymbols(obj);for (const key2 of objGetSymbol) &#123; console.log(key2);&#125;// Symbol(a)// Symbol(b) 总结 for in 主要是遍历对象 for of 遍历具有iterator接口的数据结构","categories":[{"name":"JS Base","slug":"JS-Base","permalink":"http://example.com/categories/JS-Base/"}],"tags":[{"name":"技术 语言","slug":"技术-语言","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"}]},{"title":"isNumber","slug":"JS_Base/isNumber","date":"2023-07-11T13:29:32.000Z","updated":"2023-07-11T14:11:55.519Z","comments":true,"path":"2023/07/11/JS_Base/isNumber/","link":"","permalink":"http://example.com/2023/07/11/JS_Base/isNumber/","excerpt":"","text":"判断是否为数字 JavaScript 判断是否为数字的几种方式 js判断是否为数字的方式很多： typeof、instanceof、Number、isNumber parseInt、parseFloat isNaN、isFinite Number、isNaN、Number、isFinite 正则表达式 终极方案 1.typeof、instanceof、Number.isInteger typeof判断值是不是基本类型number，比如： 12let num = 1;typeof num === &#x27;number&#x27;; // true instanceof判断值是不是包装类Number，比如： 12let num = new Number(1);num instanceof Number; // true Number、isInteger判断值是否是整数： 123Number.isInteger(1); // trueNumber.isInteger(&#x27;1&#x27;); // falseNumber.isInteger(1.1); // false 这几种方式的缺点，都是只能基于类型判断，无法判断字符串是否是数值。 2.parseInt、parseFloat 特点：返回字符串开头最长的有效数字。 我们可以用!isNaN(parseFloat(value))来判断字符串是否是数值。 123456let str1 = &#x27;123&#x27;;let str2 = &#x27;abc&#x27;;let str3 = &#x27;123654abc&#x27;;console.log(!isNaN(parseFloat(str1))); // true，是数字console.log(!isNaN(parseFloat(str2))); // false，不是数字console.log(!isNaN(parseFloat(str3))); // true parseInt和parseFloat解析的时候遇到非法字符结束，返回解析到的数值。也就是说只要字符串头部是合法数值，那么就能解析出数值，哪怕整体不是数值。比如123abc，会被解析程123。 因此，上面的判断方式还不够严谨，下面的终极方案是比较严谨的方式。 3.isNaN、isFinite NaN，表示Not-a-Number。两个NaN无法直接比较相等，因为我们只知道它不是数值，是啥不确定，也就无法比较相等。123NaN === NaN; // falseNaN == NaN; // falseObject.is(NaN, NaN); // false -&gt; true ？？？ isNaN(value)，如果ToNumber(value)的结果为NaN返回true，否则返回false。 isFinite(value)，如果ToNumber(value)的结果为数值，且不等于Infinity或-Infinity返回true，否则返回false。 isNaN和isFinite都会先将传入的值转成数值，再进行判断。ToNumber的规则跟直接使用Number函数一样。一些非数值在类型转换的时候都能转成数值，比如：1234Number(true); // 1Number(false); // 0Number(null); // 0Number(&#x27;&#x27;); // 0 对null、true、false、&#39;&#39;使用isNaN结果都是false，但是它们本身不是数值，因此不能单独使用isNaN。 4. Number.isNaN、Number.isFinite 这两个方法跟对应的全局方法是不一样的。 Number.isNaN(value)，如果value为NaN返回true，否则返回false。 Number.isFinite(value)，如果value为数值，且不等于Infinity或-Infinity返回true，否则返回false。 区别是全局方法会有强制类型转换，而这两个方法没有强制类型转换： 12345Number.isNaN(null); // true -&gt; false ？？？Number.isNaN(true); // true -&gt; false ？？？Number.isNaN(false); // true -&gt; false ？？？Number.isNaN(&#x27;&#x27;); // true -&gt; false ？？？Number.isNaN(&#x27;123&#x27;) // false 由于没有类型转换，所以Number.isNaN判断null、true、false、&#39;&#39;的结果都是true。 ~~ 但是“副作用”是数字字符串也会得到true：~~ 由于没有类型转换，所以Number.isNaN判断null、true、false、&#39;&#39;的结果都是false 。 但是副作用是数字字符串也会得到false 123456789//Number.isNaN`等价于：Number.isNaN = Number.isNaN || function(value) &#123; return typeof value === &quot;number&quot; &amp;&amp; isNaN(value);&#125;//Number.isFinite等价于：if (Number.isFinite === undefined) Number.isFinite = function(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; isFinite(value);&#125; 因此，这两个方法本质上也是基于类型的，没法判断一个字符串是否为数值。 5. 正则表达式123let exp = /^[+-]?\\d*(\\.\\d*)?(e[+-]?\\d+)?$/;exp.test(&#x27;+1.9&#x27;); // trueexp.test(&#x27;-.1e11&#x27;); // true 这个正则可以判断整数、浮点数、正负数和科学计数法。 不过我觉得判断是否是数值用正则，有点小题大做了。 6. 终极方案（推荐） 我们先看方案： 1!isNaN(parseFloat(value)) &amp;&amp; isFinite(value); 这其实是jquery中$.isNumeric的源码，多么简洁且优雅。 接下来我们看看它的原理，我们以字符串123abc为例，我们应该得到false。 parseFloat(&#39;123abc&#39;)得到123； !isNaN(123)得到true； isFinite(&#39;123abc&#39;)得到false； 最终结果为false。 单独使用!isNaN(parseFloat(value))会将123abc当成数值，所以用isFinite额外判断一次，isFinite的另一个作用是排除无穷数。 12!isNaN(parseFloat(Infinity)); // true!isNaN(parseFloat(Infinity)) &amp;&amp; isFinite(Infinity); // false 而且，因为parseFloat的解析是纯字符串解析，没有类型转换，所以不会将null、true、false、&#39;&#39;当成数值。 1234!isNaN(parseFloat(null)) &amp;&amp; isFinite(null); // false!isNaN(parseFloat(true)) &amp;&amp; isFinite(true); // false!isNaN(parseFloat(false)) &amp;&amp; isFinite(false); // false!isNaN(parseFloat(&#x27;&#x27;)) &amp;&amp; isFinite(&#x27;&#x27;); // false 判断是否为整数正则表达式1234let str=&#x27;212.1&#x27;;if(!/^\\d+$/.test(str))&#125; es612let str=&#x27;212.1&#x27;;console.log(Number.isInteger(str))","categories":[{"name":"JS Base","slug":"JS-Base","permalink":"http://example.com/categories/JS-Base/"}],"tags":[{"name":"技术 语言","slug":"技术-语言","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"游戏优化","slug":"游戏优化","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96/"},{"name":"JS Base","slug":"JS-Base","permalink":"http://example.com/categories/JS-Base/"}],"tags":[{"name":"drawcall","slug":"drawcall","permalink":"http://example.com/tags/drawcall/"},{"name":"技术 语言","slug":"技术-语言","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"}]}