<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-11T14:37:21.552Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Tree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DrawCall</title>
    <link href="http://example.com/2023/07/11/DrawCall/"/>
    <id>http://example.com/2023/07/11/DrawCall/</id>
    <published>2023-07-11T14:36:41.000Z</published>
    <updated>2023-07-11T14:37:21.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Drawcall"><a href="#Drawcall" class="headerlink" title="Drawcall"></a>Drawcall</h1><ul><li><p><code>DrawCall</code>:绘制调用，指<code>CPU</code>调用图形绘制接口命令<code>GPU</code>进行图形绘制。</p></li><li><p><code>DrawCall</code> 中文译为“绘制调用”或“绘图指令”。</p></li><li><p><code>DrawCall</code> 是一种行为（指令），即<code>CPU</code>调用图形<code>API</code>，命令<code>GPU</code>进行图形绘制。</p></li><li><p>一般来说<code>GPU</code>渲染图像的速度其实是非常快的。<br>但是<code>CPU</code>的内存显存读写、数据处理和渲染状态切换相对于<code>GPU</code>渲染来说是非常非常慢的。<br>实际的瓶颈在于<code>CPU</code>这边，大量的<code>DrawCall</code>会让<code>CPU</code>忙到焦头烂额晕头转向不可开交，而<code>GPU</code>大部分时间都在摸鱼，是导致游戏性能下降的主要原因。</p></li></ul><h2 id="降低DrawCall的方法"><a href="#降低DrawCall的方法" class="headerlink" title="降低DrawCall的方法"></a>降低DrawCall的方法</h2><ul><li>1.相同类型（图片，文本等）的节点尽量在一起，防止打断合批</li><li>2.用第三方软件<code>TexturePacker</code>等打包图集，同一个界面上的碎图尽量打包在同一图集上</li><li>3.用引擎自带的自动图集资源（<code>Auto Atlas</code>）(静态合图)打包碎图,效果只在打包后才会显示。</li><li>4.引擎动态合图功能，默认自动开启，因动态合图会增加内存，小游戏和app平台禁用动态合图。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cc.<span class="property">macro</span>.<span class="property">CLEANUP_IMAGE_CACHE</span> = <span class="literal">false</span>;</span><br><span class="line">cc.<span class="property">dynamicAtlasManager</span>.<span class="property">enabled</span> = <span class="literal">true</span>;</span><br><span class="line">cc.<span class="property">dynamicAtlasManager</span>.<span class="property">maxFrameSize</span> = <span class="number">512</span>;</span><br><span class="line">cc.<span class="property">dynamicAtlasManager</span>.<span class="title function_">showDebug</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h1 id="优化DrawCall方案"><a href="#优化DrawCall方案" class="headerlink" title="优化DrawCall方案"></a>优化DrawCall方案</h1><h2 id="1-DrawCall-CPU发送指令GPU绘制界面"><a href="#1-DrawCall-CPU发送指令GPU绘制界面" class="headerlink" title="1.DrawCall -CPU发送指令GPU绘制界面"></a><em><strong>1.DrawCall -CPU发送指令GPU绘制界面</strong></em></h2><ul><li><a href="https://mp.weixin.qq.com/s/XjjwbmCzTQZd6snN82Q8jA">Cocos Creator ScrollView 性能优化</a>    </li><li><a href="https://forum.cocos.org/t/topic/137618">不改引擎源码实现虚拟列表合批策略</a>   </li><li><a href="https://forum.cocos.org/t/postrender-demo/95201">【分享】利用PostRender实现分层合批渲染（附 Demo 和引擎源码解读）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Drawcall&quot;&gt;&lt;a href=&quot;#Drawcall&quot; class=&quot;headerlink&quot; title=&quot;Drawcall&quot;&gt;&lt;/a&gt;Drawcall&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;DrawCall&lt;/code&gt;:绘制调用，指&lt;code&gt;CPU</summary>
      
    
    
    
    <category term="游戏优化" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="drawcall" scheme="http://example.com/tags/drawcall/"/>
    
  </entry>
  
  <entry>
    <title>JS 基础</title>
    <link href="http://example.com/2023/07/11/JS_Base/JS/"/>
    <id>http://example.com/2023/07/11/JS_Base/JS/</id>
    <published>2023-07-11T13:29:32.000Z</published>
    <updated>2023-07-11T14:11:38.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h1><h1 id="js-基础"><a href="#js-基础" class="headerlink" title="js 基础"></a>js 基础</h1><ul><li><p>所有的数字类型,在<code>JavaScript</code>中,都是双倍精度的浮点数类型</p></li><li><p><code>Javascript</code>的数字类型是双精度浮点型.</p></li><li><p>在<code>Javascript</code>中,整型是<code>double</code>的一个子集,而不是一个独立的数据类型.</p></li><li><p><code>Javascript</code>在进行位运算的时候会把数字转换成32位整型来进行处理.</p></li><li><p>浮点数运算是不准确的,拥有许多的局限性.</p></li><li><p><code>javaScript</code>最大值为2的53次方&#x3D;&#x3D;&#x3D;9007199254740992。</p></li></ul><h2 id="‘-’-与-‘-’"><a href="#‘-’-与-‘-’" class="headerlink" title="‘|’ 与 ‘||’"></a>‘|’ 与 ‘||’</h2><h3 id="JS-单竖线运算符"><a href="#JS-单竖线运算符" class="headerlink" title="JS 单竖线运算符"></a>JS 单竖线运算符</h3><p>在<code>js</code>开发应用中我们通常会碰到<code>&#39;|&#39;</code>与<code>&#39;||&#39;</code>了，那么在运算中<code>&#39;|&#39;</code>与<code>&#39;||&#39;</code>是什么意思呢？<br>在<code>js</code>整数操作的时候，相当于去除小数点，<code>parseInt</code>。在正数的时候相当于<code>Math.floor()</code>,负数的时候相当于<code>Math.ceil()</code>  </p><p>注：</p><ol><li>Math.ceil()用作向上取整。</li><li>Math.floor()用作向下取整。</li><li>Math.round() 我们数学中常用到的四舍五入取整。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.6</span>|<span class="number">0</span>)<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1.1</span>|<span class="number">0</span>)<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3.65555</span>|<span class="number">0</span>)<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5.99999</span>|<span class="number">0</span>)<span class="comment">//5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">7.777</span>|<span class="number">0</span>)<span class="comment">//-7</span></span><br></pre></td></tr></table></figure>单竖杠的运算规则</li></ol><p>看了上面的例子，大体知道单竖杠可以进行取整运算，就是只保留正数部分，小数部分通过拿掉，但是<code>&#39;|0&#39;</code>，又是如何进行运算的呢，为什么能<code>&#39;|0&#39;</code>能达到取整的目的呢？单竖杠不是<code>0</code>有会是多少呢？</p><p>带着这些问题，我们看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>|<span class="number">4</span>);<span class="comment">//7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>|<span class="number">4</span>);<span class="comment">//4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>|<span class="number">3</span>);<span class="comment">//11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5.3</span>|<span class="number">4.1</span>);<span class="comment">//5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>|<span class="number">3455</span>);<span class="comment">//3455</span></span><br></pre></td></tr></table></figure><p>这里面提到了单竖杠<code>&#39;|&#39;</code>但是没有<code>javascript</code>的。<br>好吧，我在这里公布答案吧。其实单竖杠<code>&#39;|&#39;</code>就是转换为<code>2进制</code>之后相加得到的结果。例如我们拿简单的举例：</p><p>3|4<br>转换为二进制之后011|100  相加得到111&#x3D;7<br>4|4<br>转换为二进制之后100 |100  相加得到100&#x3D;4<br>8|3<br>转换为二进制之后1000 |011  相加得到1011&#x3D;11</p><p>以此类推，我在这里就不一一列举了，单竖杠<code>&#39;|&#39;</code>运算就是转换为2进制之后相加得到的结果！</p><h3 id="JS-双竖线运算符"><a href="#JS-双竖线运算符" class="headerlink" title="JS 双竖线运算符"></a>JS 双竖线运算符</h3><p>1、JS双竖线运算符:是或比较.如<code>null||&#39;1&#39;</code>,返回<code>&#39;1&#39;</code>;<code>&#39;2&#39;||&#39;1&#39;</code>,返回<code>&#39;2&#39;</code>.即或运算符中,第一个为真,后面的就不用计算了.所以得<code>&#39;2&#39;</code>。<br>2、js 中 使用双竖线运算符<code>&quot;||&quot;</code>,返回第一个有效值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objOne = <span class="literal">undefined</span> || <span class="number">1</span> || <span class="literal">null</span> || <span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line"><span class="keyword">var</span> objTwo = <span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line"><span class="keyword">var</span> objThree = objOne || objTwo; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objThree.<span class="title function_">toString</span>()); <span class="comment">//out put &quot;1&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>性能上的比较</p></li><li><p>逻辑运算符<code>&amp;&amp; ||</code> 中，如果&amp;&amp;的第一个运算数是<code>false</code>，就不再考虑第二个运算数，直接返回<code>false</code>；如果<code>||</code>的第一个运算数是<code>true</code>，也不再考虑第二个运算数，直接返回<code>true</code>。而<code>&amp;</code>和<code>|</code>运算符却不是这样的，它们总是要比较两个运算数才得出结果，因而性能上<code>&amp;&amp;</code>和<code>||</code>会比<code>&amp;</code>和<code>|</code>好。</p></li></ul><p>功能用法</p><p><code>&amp;&amp;</code>和<code>||</code>只能进行逻辑运算，而<code>&amp;</code>和<code>|</code>除了可以进行”逻辑运算”外，还可以进行位运算</p><p>位运算</p><p><code>&amp;</code>和<code>|</code>本是位运算符，之所以可以进行”逻辑运算”，是由于<code>JS</code>是无类型的语言、各数据类型可以自由转换这一特性决定的，当用<code>&amp;</code>和<code>|</code>进行”逻辑运算”时，实际上<code>true</code>被转换成<code>1</code>，<code>false</code>被转换成<code>0</code>，再进行逐位运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> &amp; <span class="literal">false</span>); <span class="comment">//JS，结果为0</span></span><br><span class="line"><span class="comment">// 上面这句，实例等同于逻辑运算被转化成下面的位运算，并执行：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &amp; <span class="number">0</span>); <span class="comment">//JS，结果为0</span></span><br><span class="line"><span class="comment">// 也正是由于&amp;和|是逐位运算符，才出现了第一点中所说的，它们总是要比较两个运算数才得出结果，才导致性能会比&amp;&amp;和||低一些。</span></span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><ul><li><p><strong><code>eval</code>可以将字符串生成语句执行，</strong> 和<code>SQL</code>的<code>exec()</code>类似。</p></li><li><p><code>eval</code>的使用场合是什么呢？有时候我们预先不知道要执行什么语句，只有 当条件和参数给时才知道执行什么语句，这时候<code>eval</code>就派上用场了。举个例子：</p></li><li><p>我们要做一个<code>function()</code>，功能是输入网页中两个个对象的名称，然后程序就将这两个对象的值联接起来输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">output</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> tmpa,tmpb;</span><br><span class="line">   tmpa=<span class="variable language_">document</span>.<span class="property">all</span>.<span class="property">a</span>.<span class="property">value</span>;</span><br><span class="line">   tmpb=<span class="variable language_">document</span>.<span class="property">all</span>.<span class="property">b</span>.<span class="property">value</span>;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(tmpa+tmpb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">output</span>(<span class="string">&#x27;input1&#x27;</span>,<span class="string">&#x27;input2&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>这样你执行的时候就会提示错误<code>“document.all.a</code>不是对象”以及<code>“document.all.b</code>不是对象”。原来<code>javascript</code>把<code>a</code>和 <code>b</code>当成对象名称了，怎样能让<code>javascript</code>把<code>a</code>里面的值作为对象名称呢<code>？</code>这时候就要用<code>eval</code>了，把代码改成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">output</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tmpa,tmpb;</span><br><span class="line">tmpa=<span class="built_in">eval</span>(<span class="string">&quot;document.all.&quot;</span>+a+<span class="string">&quot;.value&quot;</span>);</span><br><span class="line">tmpb=<span class="built_in">eval</span>(<span class="string">&quot;document.all.&quot;</span>+b+<span class="string">&quot;.value&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(tmpa+tmpb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">output</span>(<span class="string">&#x27;input1&#x27;</span>,<span class="string">&#x27;input2&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>这样<code>javascript</code>就会先取出<code>a,b</code>的值，然后和前面的<code>document.all.</code>以及后面的<code>.value</code>组合运行，于是就可以顺利取出<code>input1</code>和<code>input2</code>的值.</p></li></ul><p><a href="https://www.cnblogs.com/shitianzeng/articles/2320164.html">参考</a></p><h2 id="JS截取字符串"><a href="#JS截取字符串" class="headerlink" title="JS截取字符串"></a>JS截取字符串</h2><ol><li><code>substring</code><br><code>string.substring(from, to)</code> 方法从 <code>from</code> 位置截取到 <code>to</code> 位置，<code>to</code> 可选，没有设置时默认到末尾。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;www.runoob.com!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">4</span>)); <span class="comment">// 从第 5 个字符开始截取到末尾</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">4</span>,<span class="number">10</span>)); <span class="comment">// 从第 5 个字符开始截取到第10个字符</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>substr</code><br><code>substr</code>方法可在字符串中截取从开始下标开始的指定数目的字符。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;www.runoob.com!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">4</span>,<span class="number">6</span>)); <span class="comment">// 从第 4 个字符开始截取6个字符</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>slice</code><br><code>slice(start,end)</code> 方法用于提取字符串的某个部分（从参数 <code>start</code> 到 <code>end </code>位置），并以新的字符串返回被提取的部分。类似 <code>substring</code>()。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;www.runoob.com!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">4</span>)); <span class="comment">// 从第 5 个字符开始截取到末尾</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">4</span>,<span class="number">10</span>)); <span class="comment">// 从第 5 个字符开始截取到第10个字符</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NOTES&quot;&gt;&lt;a href=&quot;#NOTES&quot; class=&quot;headerlink&quot; title=&quot;NOTES&quot;&gt;&lt;/a&gt;NOTES&lt;/h1&gt;&lt;h1 id=&quot;js-基础&quot;&gt;&lt;a href=&quot;#js-基础&quot; class=&quot;headerlink&quot; title=&quot;js </summary>
      
    
    
    
    <category term="JS Base" scheme="http://example.com/categories/JS-Base/"/>
    
    
    <category term="技术 语言" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>for</title>
    <link href="http://example.com/2023/07/11/JS_Base/for/"/>
    <id>http://example.com/2023/07/11/JS_Base/for/</id>
    <published>2023-07-11T13:29:32.000Z</published>
    <updated>2023-07-11T14:11:55.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><h2 id="for-in-与-for-of-的区别？"><a href="#for-in-与-for-of-的区别？" class="headerlink" title="for in 与 for of 的区别？"></a>for in 与 for of 的区别？</h2><ul><li>遍历对象</li></ul><ol><li>for…in 遍历对象的属性</li><li>for…of 用来遍历具有iterator接口的数据结构（set map arguments NodeList）</li></ol><ul><li>遍历数组</li></ul><ol><li>for…in 遍历的是数组的索引</li><li>for…of 遍历的是数组的值</li><li>forEach 不能使用break continue for…in for…of可以使用</li><li>for of 遍历对象 Object.keys</li><li>argument NodeList</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo2</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ol start="6"><li>不能遍历 Symbol 属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">as</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> bs = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="keyword">as</span>]: <span class="string">&#x27;as&#x27;</span>,</span><br><span class="line">    [bs]: <span class="string">&#x27;bs&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// console.log(key);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以遍历Symbol的方法</span></span><br><span class="line"><span class="comment">// Object.getOwnPropertySymbols()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objGetSymbol = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key2 <span class="keyword">of</span> objGetSymbol) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Symbol(a)</span></span><br><span class="line"><span class="comment">// Symbol(b)</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>for in 主要是遍历对象</li><li>for of 遍历具有iterator接口的数据结构</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;for&quot;&gt;&lt;a href=&quot;#for&quot; class=&quot;headerlink&quot; title=&quot;for&quot;&gt;&lt;/a&gt;for&lt;/h1&gt;&lt;h2 id=&quot;for-in-与-for-of-的区别？&quot;&gt;&lt;a href=&quot;#for-in-与-for-of-的区别？&quot; class=&quot;</summary>
      
    
    
    
    <category term="JS Base" scheme="http://example.com/categories/JS-Base/"/>
    
    
    <category term="技术 语言" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>isNumber</title>
    <link href="http://example.com/2023/07/11/JS_Base/isNumber/"/>
    <id>http://example.com/2023/07/11/JS_Base/isNumber/</id>
    <published>2023-07-11T13:29:32.000Z</published>
    <updated>2023-07-11T14:11:55.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断是否为数字"><a href="#判断是否为数字" class="headerlink" title="判断是否为数字"></a>判断是否为数字</h1><ul><li><p><a href="https://blog.csdn.net/qq_23365135/article/details/123833406">JavaScript 判断是否为数字的几种方式</a></p></li><li><p>js判断是否为数字的方式很多：</p><ol><li><code>typeof</code>、<code>instanceof</code>、<code>Number</code>、<code>isNumber</code></li><li><code>parseInt</code>、<code>parseFloat</code></li><li><code>isNaN</code>、<code>isFinite</code></li><li><code>Number</code>、<code>isNaN</code>、<code>Number</code>、<code>isFinite</code></li><li>正则表达式</li><li>终极方案</li></ol></li></ul><h2 id="1-typeof、instanceof、Number-isInteger"><a href="#1-typeof、instanceof、Number-isInteger" class="headerlink" title="1.typeof、instanceof、Number.isInteger"></a>1.typeof、instanceof、Number.isInteger</h2><ul><li><p><code>typeof</code>判断值是不是基本类型<code>number</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typeof</span> num === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>instanceof</code>判断值是不是包装类<code>Number</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>);</span><br><span class="line">num <span class="keyword">instanceof</span> <span class="title class_">Number</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number</code>、<code>isInteger</code>判断值是否是整数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1.1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>这几种方式的缺点，都是只能基于类型判断，无法判断字符串是否是数值。</p></li></ul><h2 id="2-parseInt、parseFloat"><a href="#2-parseInt、parseFloat" class="headerlink" title="2.parseInt、parseFloat"></a>2.parseInt、parseFloat</h2><ul><li><p>特点：返回字符串开头最长的有效数字。</p></li><li><p>我们可以用<code>!isNaN(parseFloat(value))</code>来判断字符串是否是数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">&#x27;123654abc&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(str1))); <span class="comment">// true，是数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(str2))); <span class="comment">// false，不是数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(str3))); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>parseInt</code>和<code>parseFloat</code>解析的时候遇到非法字符结束，返回解析到的数值。也就是说只要字符串头部是合法数值，那么就能解析出数值，哪怕整体不是数值。比如123abc，会被解析程123。</p></li><li><p>因此，上面的判断方式还不够严谨，下面的终极方案是比较严谨的方式。</p></li></ul><h2 id="3-isNaN、isFinite"><a href="#3-isNaN、isFinite" class="headerlink" title="3.isNaN、isFinite"></a>3.isNaN、isFinite</h2><ul><li><code>NaN</code>，表示<code>Not-a-Number</code>。两个<code>NaN</code>无法直接比较相等，因为我们只知道它不是数值，是啥不确定，也就无法比较相等。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>;         <span class="comment">// false</span></span><br><span class="line"><span class="title class_">NaN</span> == <span class="title class_">NaN</span>;          <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>); <span class="comment">// false -&gt; true ？？？</span></span><br></pre></td></tr></table></figure></li><li><code>isNaN(value)</code>，如果<code>ToNumber(value)</code>的结果为<code>NaN</code>返回<code>true</code>，否则返回<code>false</code>。</li><li><code>isFinite(value)</code>，如果<code>ToNumber(value)</code>的结果为数值，且不等于<code>Infinity</code>或<code>-Infinity</code>返回<code>true</code>，否则返回<code>false</code>。</li><li><code>isNaN</code>和<code>isFinite</code>都会先将传入的值转成数值，再进行判断。<code>ToNumber</code>的规则跟直接使用<code>Number</code>函数一样。一些非数值在类型转换的时候都能转成数值，比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>);         <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>);        <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>);         <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>);           <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li>对<code>null</code>、<code>true</code>、<code>false</code>、<code>&#39;&#39;</code>使用<code>isNaN</code>结果都是<code>false</code>，但是它们本身不是数值，因此不能单独使用<code>isNaN</code>。</li></ul><h2 id="4-Number-isNaN、Number-isFinite"><a href="#4-Number-isNaN、Number-isFinite" class="headerlink" title="4. Number.isNaN、Number.isFinite"></a>4. Number.isNaN、Number.isFinite</h2><ul><li><p>这两个方法跟对应的全局方法是不一样的。</p></li><li><p><code>Number.isNaN(value)</code>，如果<code>value</code>为<code>NaN</code>返回<code>true</code>，否则返回<code>false</code>。</p></li><li><p><code>Number.isFinite(value)</code>，如果<code>value</code>为数值，且不等于<code>Infinity</code>或<code>-Infinity</code>返回<code>true</code>，否则返回<code>false</code>。</p></li><li><p>区别是全局方法会有强制类型转换，而这两个方法没有强制类型转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">null</span>);      <span class="comment">// true -&gt; false ？？？</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">true</span>);      <span class="comment">// true -&gt; false ？？？</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">false</span>);     <span class="comment">// true -&gt; false ？？？</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>);        <span class="comment">// true -&gt; false ？？？</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><del>由于没有类型转换，所以<code>Number.isNaN</code>判断<code>null</code>、<code>true</code>、<code>false</code>、<code>&#39;&#39;</code>的结果都是<code>true</code></del>。</p></li><li><p>~~ 但是“副作用”是数字字符串也会得到<code>true</code>：~~</p></li><li><p>由于没有类型转换，所以<code>Number.isNaN</code>判断<code>null</code>、<code>true</code>、<code>false</code>、<code>&#39;&#39;</code>的结果都是<code>false</code> 。</p></li><li><p>但是<code>副作用</code>是数字字符串也会得到<code>false</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Number.isNaN`等价于：</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">isNaN</span> = <span class="title class_">Number</span>.<span class="property">isNaN</span> || <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Number.isFinite等价于：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="property">isFinite</span> === <span class="literal">undefined</span>) <span class="title class_">Number</span>.<span class="property">isFinite</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isFinite</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因此，这两个方法本质上也是基于类型的，没法判断一个字符串是否为数值。</li></ul><h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exp = <span class="regexp">/^[+-]?\d*(\.\d*)?(e[+-]?\d+)?$/</span>;</span><br><span class="line">exp.<span class="title function_">test</span>(<span class="string">&#x27;+1.9&#x27;</span>);   <span class="comment">// true</span></span><br><span class="line">exp.<span class="title function_">test</span>(<span class="string">&#x27;-.1e11&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>这个正则可以判断整数、浮点数、正负数和科学计数法。</li><li>不过我觉得判断是否是数值用正则，有点小题大做了。</li></ul><h2 id="6-终极方案（推荐）"><a href="#6-终极方案（推荐）" class="headerlink" title="6. 终极方案（推荐）"></a>6. 终极方案（推荐）</h2><ul><li><p>我们先看方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(value)) &amp;&amp; <span class="built_in">isFinite</span>(value);</span><br></pre></td></tr></table></figure></li><li><p>这其实是<code>jquery</code>中<code>$.isNumeric</code>的源码，多么简洁且优雅。</p></li><li><p>接下来我们看看它的原理，我们以字符串<code>123abc</code>为例，我们应该得到<code>false</code>。</p></li><li><p><code>parseFloat(&#39;123abc&#39;)</code>得到<code>123</code>；</p></li><li><p><code>!isNaN(123)</code>得到<code>true</code>；</p></li><li><p><code>isFinite(&#39;123abc&#39;)</code>得到<code>false</code>；</p></li><li><p>最终结果为<code>false</code>。</p></li><li><p>单独使用<code>!isNaN(parseFloat(value))</code>会将123abc当成数值，所以用<code>isFinite</code>额外判断一次，<code>isFinite</code>的另一个作用是排除无穷数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="title class_">Infinity</span>));  <span class="comment">// true</span></span><br><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="title class_">Infinity</span>)) &amp;&amp; <span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>而且，因为<code>parseFloat</code>的解析是<code>纯字符串解析</code>，没有类型转换，所以不会将<code>null</code>、<code>true</code>、<code>false</code>、<code>&#39;&#39;</code>当成数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="literal">null</span>)) &amp;&amp; <span class="built_in">isFinite</span>(<span class="literal">null</span>);   <span class="comment">// false</span></span><br><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="literal">true</span>)) &amp;&amp; <span class="built_in">isFinite</span>(<span class="literal">true</span>);   <span class="comment">// false</span></span><br><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="literal">false</span>)) &amp;&amp; <span class="built_in">isFinite</span>(<span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line">!<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>)) &amp;&amp; <span class="built_in">isFinite</span>(<span class="string">&#x27;&#x27;</span>);       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="判断是否为整数"><a href="#判断是否为整数" class="headerlink" title="判断是否为整数"></a>判断是否为整数</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;212.1&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(str))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;212.1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(str))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断是否为数字&quot;&gt;&lt;a href=&quot;#判断是否为数字&quot; class=&quot;headerlink&quot; title=&quot;判断是否为数字&quot;&gt;&lt;/a&gt;判断是否为数字&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_2336513</summary>
      
    
    
    
    <category term="JS Base" scheme="http://example.com/categories/JS-Base/"/>
    
    
    <category term="技术 语言" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
